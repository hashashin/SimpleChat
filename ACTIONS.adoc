= Action language
Jim Finnis <jim.finnis@gmail.com>
// settings
:toc:
:toc-placement!:

toc::[]


The action language is used inside pattern actions and user functions,
for example in a topic file:
----
+.*:
    "I have no idea what to say to that";
----
the last line
----
    "I have no idea what to say to that";
----
is a very simple action which outputs a string.


== Basic operations

The action language is based on Angort, because it was pretty easy to write
a quick-and-dirty parser and interpreter for such a language. As such, it's
a Forth-based RPN stack language. This means that there is a notional
"stack" of values, and each command in the language does thing to the stack.
In most languages, you'd perform a simple calculation and output a value
with a command like
----
output(12+2*8)
----
but in action language, this would be
----
2 8 * 12 + output
----
Line breaks and white space can be used freely, and comments begin
with hashes, so we could write this more fully as:
----
2       #   put 2 on the stack
8       #   put 8 on the stack
*       #   multiply the top two stack values and replace with the result
12      #   put 12 on the stack
+       #   add the top two stack values and replace with the result
output  #   perform the "output" command
----
The "output" command doesn't exist in action language, since we usually
output by leaving a value on the stack at the end of the code. 
But here's a real example, which is a pattern/action pair you might find
in a topic to read two numbers and add them together:
----
+"(add $foo=. $bar=.)"
    $foo double # stack the first argument and convert to double
    $bar double # stack the second argument and convert to double
    + str       # add together the two top stack values and convert to string
;
----

=== Stacking constants
A quoted string or number compile to instructions which stack them as strings, double-precision
floating point (referred to as "doubles" hereafter) or integers. So the following snippet
would leave some values on the stack:
----
4 3.2 "hello"
----
[NOTE]
====
- Integers are stacked if the number is equal to its floor, so `2.0` will be stacked as the
integer 2. This is due to how the tokeniser works, sorry.
- Lists such as `[1,2,3,4]` look like constants, but are in fact generated by executable code.
See below for more details.
====

There is a useful shortcut for stacking single words, often called "symbols".
Any single word which begins with a backtick is a symbol to be placed on 
the stack:
----
`cat `dog +
----
would produce the string "catdog".


==== Embedding code in strings
While most string constants just look like `"hello, I'm a string"`, it's possible to embed
small fragments of code in them in between `${` and `}`. For example:
```
"hello, ${$@name}, pleased to meet you!"
```
or even
```
+"gronk"
    "this is the ${?@gronk 1+ dup !@gronk}th time you've said that.";
```
Don't do what I did in the example above and try to be too clever in your embedded code -
just use it for accessing variables.
They are generally best used for accessing the pattern variables assigned in the matched
pattern:
```
+"(is $n=(?a ~cat) a cat)" "Yes ${$n} is a cat";
```
[NOTE]
====
Code cannot be embedded in symbols.
====

==== Subpattern lists
The *subpattern list*
literal is rather complex, and looks like a list of patterns inside curly brackets,
just as you would find in a topic, but without the preceding `+` or name on each pattern:
----
    {
        "(?Iam [ok good fine well] .*)"
            "Glad to hear it.";
        "(?Iam [bad (not ?too ^bad)] .*)"
            "Oh, I'm sorry";
        ".*" "Righto.";
    } next
----
will stack a subpattern list, which is then used to try to match the next input with
the `next` command.

=== Output
The primary purpose of an action is to respond to the user with text.
There are two ways to do this.

- *Stack output*: The simplest method is simply to return a string on the stack.
If there is any value left over on the stack at the end of an action, it will
be converted to a string and sent to the user. All the examples so far have been of this
kind.
- *The string builder*: Sometimes it's necessary to build a more complex string.
You could do this by concatenation (e.g. `"building " "a "+ "string"+`) but all the stack
operations be hard to read. Instead, the string builder can be used. Here, the
`.` operation appends to a string inside the conversation. If there is no value left on
the stack at the end of the action's run, the resulting string is returned.
Here's a simple example:
----
"Hello ".                           # add "Hello " to the output
["you", ?@name, "friend"] choose .  # followed by one of these strings
"." .                               # followed by "."
----
If an action ends with no value on the stack and an empty string builder,
the pattern matcher will consider the pattern to have failed to match and will
move on to the next pattern in the topic.

The string builder has a couple of commands which can be useful:

- `out` will stack the contents of the string builder without clearing it. If the
builder is empty, `none` will be stacked.
- `clearout` will clear the string builder to its uninitialized state.


=== Maths and comparison operators
Binary operations have the stack picture `(a b -- c)`: that is, they remove two items
from the stack and replace them with a single item.

- `+` adds the values. If either is a string, will convert both to strings and concatenate them; if both are lists will create a new list of the two joined together.
- `-` subtracts `b` from `a`, both must be numbers, result double if either is a double
- `/` divides `b` by `a`, both must be numbers, result double if either is a double
- `%` finds `a` mod `b`, both must be numbers, result double if either is a double
- `=` pushes 1 if the values are the same type and equal, 0 otherwise
- `!=` pushes 0 if the values are the same type and equal, 1 otherwise
- `<` pushes 1 if `a` < `b`, else pushes 0
- `<=` pushes 1 if `a` <= `b`, else pushes 0
- `>` pushes 1 if `a` > `b`, else pushes 0
- `>=` pushes 1 if `a` >= `b`, else pushes 0

Unary operations have the stack picture `(a -- b)`: they replace a value with a modified value.
The core operations supported are:

- `not` replaces a nonzero value with zero, and vice versa
- `neg` replaces the value with its negative (having converted it to a number)

=== Conversion functions
These all have the picture `(a -- b)`, like unary operators, and convert between types.

- `double` converts to a string
- `int` converts to an integer
- `str` converts to a string

=== String functions
- `trim` `(a -- b)` trims leading and trailing whitespace from a string

=== Stack manipulation
- `dup` `(a -- a a)` duplicates the item on top of the stack
- `swap` `(a b -- b a)` swap the top two items
- `drop` `(a --)` discard the top stack value
=== Debugging
- `dp` `(a --)` prints a value to the system logger

=== Variable access
There are four sets of variables:

- *instance* variables are private to each `BotInstance`, each communicating entity.
- *conversation* variables are private to each `BotInstance/source` pair, that is,
each conversation between a bot and a user.
- *pattern* variables are those matched in a pattern, such as `foo` and `bar` in the example
above.
- *function* variables are local to user functions

The different sorts of variables have different sigils in front of their name:

- conversation and function variables have no sigil, they are the default.
- instance variables have the `@` sigil
- pattern variables have the `$` sigil

[NOTE]
====
If a function variable of the same name as a conversation variable is
in scope, the function variable hides the conversation variable
====

==== Fetching variables
- `!varname` will pop the stack and store into the conversation/function variable `varname`. 
- `?varname` will push the value of conversation/function variable `varname`, or the string `none` if 
it has not been set.
- `?@varname` will pop the stack and store into the instance  variable `varname`. 
- `?@varname` will push the value of instance variable `varname`, or the string `"??"` if 
it has not been set.
- `$varname` will push the value of pattern variable `varname`, or `"??"` if not set - note
that there is no `?` here, because you cannot set a pattern variable.

== Pattern manipulation
- `recurse` `(s --)` feeds the string back into the conversation system as if it were
spoken to the bot, and stacks the result. Take care you don't recurse infinitely!
- `next` `(p --)` specifies the subpattern block to use for preferential matching of the next input.
- `hasnext` ( -- bool)` pushes whether the conversation has a special subpattern to run; typically used for suppressing random comments from action functions called with `runFunc()` 
- `promote` `(topicname --)` promotes a topic to the top of its list
- `demote` `(topicname --)` demotes a topic to the bottom of its list
- `enabletopic` `(topicname --)` enables a topic if it was disabled
- `disabletopic` `(topicname --)` disables a topic if it was enabled
- `enablepattern` `(patternname topicname --)` enables a disabled named pattern in a topic
- `disablepattern` `(patternname topicname --)` disables an enabled named pattern in a topic
- `curtopic` `(-- name)` return name of matched topic or `none` if not in a topic

== Flow control

### `if .. then .. else`
This is the basic flow control statement. It might seem a bit odd if you're not used to
languages of the Forth family, but it works like this:
----
<code that leaves integer on stack>
if
<part that runs if integer was true>
then
----
or
----
<code that leaves integer on stack>
if
<part that runs if integer was true>
then
<part that runs if integer was false>
else
----
For example
----
?@foo 5 = if "Five!" else "Not five!" then
----
will check if instance variable `foo` is 5. If it is, it will stack "Five!", otherwise
it will stack "Not five!" These statements can be nested.

### `cases`: or, how to do `else if`
We don't have `else if` in this language because of the way it's parsed (how would you separate
the condition part from the action part of the previous `if`?). Instead, the `cases` construction
serves the same role. It has the form
----
cases
    <condition> if <action> case
    <condition> if <action> case
    ...
    <action> otherwise
----
Here's an example which converts the string obtained from the pattern, `$n`, into an integer conversation variable for testing.
----        
    +"(case test $n=.)"
    $n int !n
    ?n 0 = if "Zero" case
    ?n 1 = if "One" case
    ?n 2 = if "Two" case
    ?n 10 < if "Between three and nine" case
    "Something else" otherwise;
----
    

=== "Infinite" loops

The words `loop` and `endloop` enclose a loop, which is notionally infinite.
The `leave` and `ifleave` words leave the enclosing loop. `ifleave` pops an integer
from the stack and leaves the loop if it is non-zero; as such it is equivalent to
`if leave then`. Loops may be nested.
This example counts to the number user specifies:
----
    +"(count to $n=.*)"
    0!ct
    ""
    loop
        ?ct 1+ !ct
        ?ct + " " +
        ?ct $n int = ifleave
    endloop trim;
----

=== Iterator loops
It is also possible to loop over values of an iterable value, such as a
<<Lists,list>> or <<Ranges,range>>. To do this, use `each loop`, and use
`i` to get the current value:
----
[1,2,3,4] each loop 
    i dup * . "\n". 
endloop
----
will output the squares of the given numbers. Iterator loops (and all loops) can be
nested. If you want to access the current value of the next loop out, use `j`; and for
the loop outside that use `k`. Here's a silly example of a nested loop over a pair
of lists:
----
[] ["dog","fish","cat","bird"] each loop 
    ["head","leg","arm"] each loop
        j i + ,
    endloop
endloop
", " join
----
will print "doghead, dogleg, dogarm, fishhead, fishleg, fisharm, cathead,
catleg, catarm, birdhead, birdleg, birdarm". (See <<Lists,list>> to understand
how it builds up the list and uses `join` to join the elements together.)

The most common use of iterator loops is to do some code a number of times:
----
0 4 range each loop "Yes!". endloop
----
will perform the code 4 times, with `i` running from 0 to 3 (but unused here).

=== Early exit 
We can exit from an action early using the `stop` word. Note that we must still
leave a string on the stack for the action to sent to the user. This word will
work inside loops and other control structures.

== The `none` value
Some operations may return this special value when they fail in some way,
for example popping an item from the end of a list of zero length or reading
an unset local variable. You
can test if the value on the stack is none with `isnone` `(val -- 0 or 1)`,
and you can stack none yourself with `none`.

== User functions
It's possible to define user functions in `config.conf` or any
topic file. To do this, use a function definition of the form
----
:name |arg1,arg2...,local1,local2...|
    function body in action language
----
The arguments will we popped off the stack, and local variables
will be allocated. Inside a function, accessing local variables and
arguments (known as *function variables*) is done the same way as
accessing conversation variables,
using the '!' and '?' sigils. Function variables take precedence over
conversation variables: if no function variable exists of that name,
the function will try to access the conversation variable.
Here's an example function:
----
:addints |s1,s2:|
    ?s1 int ?s2 int +;
----
All local variables are initialised to `none`.
You may omit the args and locals if you wish, and you can use values 
already on the stack on entry to the function:
----
addints int swap int +;
----
will do the same: convert two values to ints and add them. This latter
form is a bit more efficient (four instructions rather than five and
no function variable setup) and works by converting the top int,
swapping the top two stack members, converting the second int,
and adding. Of course if you did it with a non-commutative operation
like division this wouldn't work, but you could write:
----
:divints int swap int swap /;
----
Functions can also call other functions, and can recurse,
so you can have a function and pattern like this:
----
:fac |n:|
    ?n 1 = if
        1
    else
        ?n 1 - fac ?n *
    then   
;

+"(fac $n=.)"
    $n int fac
;
----
Important: functions are global to all files - a function defined in a
config file or a topic will be there for all subsequent topics.

== Lists
Lists are created using the `[`, `]` and `,` stack operators.
The `[` operator creates a new list and puts it on the stack. The `,` and `]` operators
both append the item on top of the stack to the list on the stack below it (without popping
off the list). The only difference between `]` and `,` is that `[` scans forward in
the parser and throws away a `]` if it comes next.

This might seem a bit complex, but the result is that you can build a list by simply
writing out its members separated by commas, inside square brackets:
----
[1,2,3,"hello"]
----
will stack a list consisting of those four values. `[]` will stack an empty list,
because of the way `[` skips a following `]`. Here's a step-by-step look
at the previous code example:

- `[` stacks a new list
- `1` pushes the value 1 onto the stack
- `,` pops the 1 and puts it onto the list, which remains on the stack
- `2` pushes the value 2 onto the stack
- `,` pops the 2 and puts it onto the list, which remains on the stack
- `3` pushes the value 3 onto the stack
- `,` pops the 3 and puts it onto the list, which remains on the stack
- `"hello"` pushes the value "hello" onto the stack
- `]` pops the "hello" and puts it onto the list, which remains on the stack

[NOTE]
====
This peculiar behaviour becomes useful for building lists containing variables,
and when we deal with iterating over lists (giving us list comprehensions for free) -
but it is sometimes inefficient because of the number of operations. Consider using
a *constant expression* or
setting up large constant lists in instance variables in your config file's `init` action.
====

Operations on lists are:

- `get` `(idx list -- val)` gets an item from a list, or `none`
- `set` `(val idx list --)` sets an item in a list which must be of the required length; it will not grow the list
- `push` `(val list --)` appends an item to the end of the list
- `pop` `(list -- val)` removes an item from the end of the list and stacks it, or `none` if there were no items
- `unshift` `(val list --)` appends an item to the start of the list
- `shift` `(list -- val)` removes an item from the start of the list and stacks it, or `none` if there were no items
- `len` `(list -- int)` pushes the length of a list
- `choose` `(list -- item)` selects a random item from the list

The `choose` is particularly useful in selecting random responses, or even
starting random dialogue trees.


[NOTE]
====
Lists are implemented as Java ArrayList objects, which means that the `unshift` and
`shift` operations will be slower than `push` and `pop`.
====

== Ranges
Ranges are values which represent ranges of integers. For example, the range created
by `0 4 range` represents the numbers 0, 1, 2 and 3. The list doesn't include 4 so
that it's 4 integers long. The only thing that you can do with a range is iterate
over it. For example:
----
10 20 range each loop {i " " +.}
----
will print "10 11 12 13 14 15 16 17 18 19" - all the numbers from 10 to 19 joined together
by the string builder. If you want to do fancy things with a range, it's easy enough
to convert it to a list. Here's a function to do that:
----
:range2list |r:|
   [] ?r each loop i, endloop
;
----

== Constant expressions
Sometimes it is useful to write code which manipulates constants: a trivial
example might be:
----
:degs2rads |x:|
    3.14159 180.0 *
    ?x *
;
----
Although the above example is fine, complex list-building expressions can
take a large number of operations just to build a constant list. Action language
has no optimizer, but it is possible to optimize such code by enclosing it in
a *constant expression block*. This is started with a `:` and terminated by a `;`
just like a function, but appears inside a block of code. The compiler will
build the enclosed code, run it immediately, and compile an instruction which
just stacks the returned value (i.e. the value left on top of the stack of the code
it just ran). The above code could be written as
----
:degs2rads |x:| 
    :3.14159 180*; ?x *;
----
compiling to three instructions rather than five. 

[NOTE]
====
- Some operations and commands will crash inside a constant expression, because they
run in a dummy conversation without a bot instance or source. Don't try to access
an instance variable, for example.
- Premature optimisation is evil!
====

== Category manipulation
Categories are also values, and those defined in topics can be stacked with
`~catname`. The `iscat` function can be used to tell if a string is within
the category - for this to be so, all the words in the string much match
a phrase in the category; partial matches are insufficient. If we have
a category defined as
----
~human = [Steve, Paul, "Thin Barry"]
----
then the following action language commands will produce the result 
in the right hand column:
----
"Steve" ~human iscat            1
"steve" ~human iscat            1
"Ella" ~human iscat             0
"Thin Paul" ~human iscat        0
"Thin Barry" ~human iscat       1
"Thin barry" ~human iscat       1
"Thin barry smith" ~human iscat 0


=== Creating local categories
It's sometimes useful to create and manipulate categories which are local
to an instance or even a conversation. To do this, action language can
be used to convert lists into categories which can be stored in variables.
Strings in the list are converted to words, lists are converted to subcategories,
and existing categories are also converted to subcategories.
This is done with the `cat` command, which takes a list and returns
a category.
Thus, the topic category (which is bot-global)
----
~animal=
    [
        "small dinosaur"
        bird pig aardvark yak
        ~dog=[dog dogs puppy puppies]
        ~cat=[cat cats kittens "puddy tat"]
    ]
----    
could be written to store in instance variables as
----
["small dinosaur","bird,"pig","aadvark","yak",
    ["dog","dogs","puppy","puppies"] cat dup !@dog,
    ["cat","cats","kittens","puddy tat"] cat dup !@cat
    ] cat !@animal
----
----
It is also possible to add to an existing category with `addcat`.
This takes a value and a category, and adds the value (either a string
or another category) to the category:
----
+"($a=(?[a an] $n=.+) is an animal)"
    $n ?@anims addcat
    "I now know that ${$a} is an animal!"
;
----
[IMPORTANT]
====
THIS DOESN'T WORK YET because the inner sequence `$n=.+` will swallow
all remaining tokens, because it doesn't know that "is" is
the next node it should look for. This is being fixes.

There's also no way to remove things from a category.
====    

[NOTE]
====
Categories defined in variables using `cat` in this way cannot be
used in pattern matching. You have to match a set of words and then
use `iscat` in the action, returning `none` if there is no match.
====
    

== Extending the language
Java code for new commands can be added to the language, which can
link to data associated with bot instance data in your code. More
details are in link:EXTENDING.adoc[this document].
